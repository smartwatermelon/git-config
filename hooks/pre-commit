#!/usr/bin/env bash
set -euo pipefail

# =========================================================
# CONFIGURATION
# =========================================================
# Tool options
SHFMT_OPTS="-d -i 2 -ci -bn"
SHFMT_WRITE_OPTS="-i 2 -ci -bn -w"
MARKDOWNLINT_OPTS="--disable=MD013"

# Auto-fix behavior (set to true/false)
AUTO_FIX_SHELL=true
AUTO_FIX_MARKDOWN=true
AUTO_FIX_SHELLCHECK=false  # More conservative due to potential complexity

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# =========================================================
# UTILITY FUNCTIONS
# =========================================================
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*"
}

# Check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Get list of staged files matching pattern
get_staged_files() {
    local pattern="$1"
    git diff --cached --name-only --diff-filter=ACM | grep -E "$pattern" || true
}

# =========================================================
# TOOL VALIDATION
# =========================================================
validate_tools() {
    local missing_tools=()

    if ! command_exists shellcheck; then
        missing_tools+=("shellcheck")
    fi

    if ! command_exists shfmt; then
        missing_tools+=("shfmt")
    fi

    if ! command_exists markdownlint; then
        missing_tools+=("markdownlint")
    fi

    if [ ${#missing_tools[@]} -gt 0 ]; then
        log_error "Missing required tools: ${missing_tools[*]}"
        log_info "Install with: brew install ${missing_tools[*]}"
        return 1
    fi

    return 0
}

# =========================================================
# SHELLCHECK PROCESSING
# =========================================================
run_shellcheck() {
    local files=("$@")
    local exit_code=0
    local issues_found=false

    log_info "Running shellcheck on ${#files[@]} shell script(s)..."

    for file in "${files[@]}"; do
        echo -e "\n${BLUE}=== Checking $file ===${NC}"

        if [ "$AUTO_FIX_SHELLCHECK" = true ]; then
            # When auto-fix is enabled, run quietly first to check for issues
            if ! shellcheck "$file" >/dev/null 2>&1; then
                issues_found=true
                log_warning "Attempting to auto-fix shellcheck issues in $file..."
                if shellcheck --format=diff "$file" | git apply; then
                    log_success "Auto-fixed shellcheck issues in $file"
                    # Re-stage the fixed file
                    git add "$file"
                else
                    log_error "Could not auto-fix shellcheck issues in $file"
                    # Show detailed output for manual review
                    shellcheck "$file"
                    exit_code=1
                fi
            else
                log_success "$file passed shellcheck"
            fi
        else
            # When auto-fix is disabled, show full verbose output
            if ! shellcheck "$file"; then
                issues_found=true
                exit_code=1
                echo ""
                log_warning "To auto-fix shellcheck issues in $file, run:"
                echo -e "${GREEN}shellcheck --format=diff '$file' | git apply && git add '$file'${NC}"
                echo ""
            else
                log_success "$file passed shellcheck"
            fi
        fi
    done

    if [ "$issues_found" = true ] && [ "$AUTO_FIX_SHELLCHECK" = false ]; then
        echo ""
        log_error "Shellcheck found issues in one or more files."
        log_info "Fix issues manually, or run the suggested commands above."
        log_info "Alternatively, enable AUTO_FIX_SHELLCHECK=true in the pre-commit hook."
        echo ""
    fi

    return $exit_code
}

# =========================================================
# SHFMT PROCESSING
# =========================================================
run_shfmt() {
    local files=("$@")
    local exit_code=0
    local issues_found=false

    log_info "Running shfmt on ${#files[@]} shell script(s)..."

    for file in "${files[@]}"; do
        # Check formatting without writing
        if ! shfmt $SHFMT_OPTS "$file" >/dev/null; then
            issues_found=true
            exit_code=1

            if [ "$AUTO_FIX_SHELL" = true ]; then
                log_warning "Auto-fixing formatting in $file..."
                if shfmt $SHFMT_WRITE_OPTS "$file"; then
                    log_success "Auto-fixed formatting in $file"
                    # Re-stage the formatted file
                    git add "$file"
                else
                    log_error "Could not auto-fix formatting in $file"
                fi
            else
                log_error "Formatting issues found in $file"
                log_info "Run: shfmt $SHFMT_WRITE_OPTS $file"
            fi
        fi
    done

    return $exit_code
}

# =========================================================
# MARKDOWNLINT PROCESSING
# =========================================================
run_markdownlint() {
    local files=("$@")
    local exit_code=0
    local issues_found=false

    log_info "Running markdownlint on ${#files[@]} markdown file(s)..."

    for file in "${files[@]}"; do
        if ! markdownlint $MARKDOWNLINT_OPTS "$file"; then
            issues_found=true
            exit_code=1

            if [ "$AUTO_FIX_MARKDOWN" = true ]; then
                log_warning "Auto-fixing markdown issues in $file..."
                if markdownlint $MARKDOWNLINT_OPTS --fix "$file"; then
                    log_success "Auto-fixed markdown issues in $file"
                    # Re-stage the fixed file
                    git add "$file"
                else
                    log_error "Could not auto-fix markdown issues in $file"
                fi
            else
                log_error "Markdown issues found in $file"
                log_info "Run: markdownlint $MARKDOWNLINT_OPTS --fix $file"
            fi
        fi
    done

    return $exit_code
}

# =========================================================
# TERRAFORM PROCESSING (Legacy)
# =========================================================
run_terraform_fmt() {
    # Check if there are any Terraform files in the current directory or subdirectories
    if [ -n "$(find . -name '*.tf')" ]; then
        log_info "Running terraform fmt..."
        terraform fmt -recursive
        log_success "Terraform formatting complete"
    fi
}

# =========================================================
# MAIN EXECUTION
# =========================================================
main() {
    log_info "Starting pre-commit checks..."

    # Validate required tools
    if ! validate_tools; then
        exit 1
    fi

    local overall_exit_code=0

    # Get staged files by type
    local shell_files
    local markdown_files

    # Shell scripts (multiple extensions and shebangs)
    shell_files=($(get_staged_files '\.(sh|bash)$'))

    # Also check for files with shell shebangs (but no extension)
    while IFS= read -r -d '' file; do
        if [[ -f "$file" ]] && [[ "$(head -n1 "$file" 2>/dev/null)" =~ ^#!.*/(ba)?sh ]]; then
            shell_files+=("$file")
        fi
    done < <(git diff --cached --name-only --diff-filter=ACM -z)

    # Markdown files
    markdown_files=($(get_staged_files '\.(md|markdown)$'))

    # Process shell files
    if [ ${#shell_files[@]} -gt 0 ]; then
        log_info "Found ${#shell_files[@]} shell script(s) to check"

        # Run shellcheck
        if ! run_shellcheck "${shell_files[@]}"; then
            overall_exit_code=1
        fi

        # Run shfmt
        if ! run_shfmt "${shell_files[@]}"; then
            overall_exit_code=1
        fi
    fi

    # Process markdown files
    if [ ${#markdown_files[@]} -gt 0 ]; then
        log_info "Found ${#markdown_files[@]} markdown file(s) to check"

        if ! run_markdownlint "${markdown_files[@]}"; then
            overall_exit_code=1
        fi
    fi

    # Legacy Terraform support
    run_terraform_fmt

    # Final status
    if [ $overall_exit_code -eq 0 ]; then
        log_success "All pre-commit checks passed!"
    else
        log_error "Pre-commit checks failed. Please fix issues before committing."

        if [ "$AUTO_FIX_SHELL" = true ] || [ "$AUTO_FIX_MARKDOWN" = true ]; then
            log_info "Some issues may have been auto-fixed. Review changes and commit again."
        fi
    fi

    exit $overall_exit_code
}

# =========================================================
# SCRIPT EXECUTION
# =========================================================
main "$@"

#!/usr/bin/env bash
set -euo pipefail

# =========================================================
# COLOR OUTPUT AND LOGGING FUNCTIONS
# =========================================================

# Color definitions
BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log() {
  echo -e "${BLUE}[PRE-PUSH]${NC} $*"
}

log_success() {
  echo -e "${GREEN}[PRE-PUSH]${NC} $*"
}

log_warning() {
  echo -e "${YELLOW}[PRE-PUSH]${NC} $*"
}

# =========================================================
# BRANCH PROTECTION - Do not push directly to main/master
# =========================================================
protected_branch_check() {
  # Read push data from stdin
  # Format: <local ref> <local sha1> <remote ref> <remote sha1>
  while read -r _local_ref _local_sha remote_ref _remote_sha; do
    # Allow tag pushes - tags don't modify branch history
    if [[ "${remote_ref}" =~ ^refs/tags/ ]]; then
      continue
    fi

    # Block direct pushes to main/master branches
    if [[ "${remote_ref}" == "refs/heads/main" || "${remote_ref}" == "refs/heads/master" ]]; then
      echo "" >&2
      echo "ðŸ›‘ STOP: Direct pushes to '${remote_ref##*/}' are not allowed." >&2
      echo "" >&2
      echo "   Use the PR workflow: branch â†’ push â†’ PR â†’ merge" >&2
      echo "" >&2
      echo "   If you REALLY need to bypass this (you probably don't):" >&2
      echo "   OBTAIN EXPLICIT PERMISSION and then git push --no-verify" >&2
      echo "" >&2
      exit 1
    fi
  done
}
protected_branch_check

# =========================================================
# ITERATIVE PR REVIEW CHECKPOINT (Protocol 4)
# =========================================================
check_pr_review_iteration() {
  # Only check if gh CLI is available
  if ! command -v gh &>/dev/null; then
    return 0
  fi

  local pr_number
  pr_number=$(gh pr view --json number -q .number 2>/dev/null || echo "")

  if [[ -n "${pr_number}" ]]; then
    echo ""
    log "Pushing to existing PR #${pr_number}"

    # Check if we're pushing after a CI failure or review comments
    local has_issues=false
    local last_ci_status=0

    # Check CI status - if gh command fails, treat as no issues (defensive)
    if gh pr checks &>/dev/null; then
      last_ci_status=$(gh pr checks 2>/dev/null | grep -ciE '\bfail(ed|ure)?\b' || true)
    fi

    if [[ "${last_ci_status}" -gt 0 ]]; then
      has_issues=true
      log_warning "âš ï¸  Last CI run had failures"
    fi

    # Check for recent review comments (claude or sentry bot)
    local recent_comments=0

    # If gh command fails, treat as no comments (defensive)
    if gh pr view --comments &>/dev/null; then
      recent_comments=$(gh pr view --comments 2>/dev/null | tail -100 | grep -ci "claude\|sentry" || true)
    fi

    if [[ "${recent_comments}" -gt 0 ]]; then
      has_issues=true
      log_warning "âš ï¸  PR has review comments"
    fi

    if [[ "${has_issues}" == true ]]; then
      echo ""
      log "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      log "PROTOCOL 4 CHECKPOINT: Iterative PR Review"
      log "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      log ""
      log "Before pushing fixes for review feedback:"
      log "  â–¡ Did code-reviewer approve these changes?"
      log "  â–¡ Or did you use adversarial-reviewer?"
      log ""
      log "THE CYCLE: fix â†’ local review â†’ commit â†’ push â†’ CI â†’ remote review â†’ repeat"
      log ""

      # Check for interactive terminal before prompting
      if [[ -t 0 ]]; then
        read -p "[PRE-PUSH] Local review clean? (y/N): " -n 1 -r
        echo
      else
        log_warning "Non-interactive mode - skipping Protocol 4 prompt"
        return 0
      fi

      if [[ ! ${REPLY} =~ ^[Yy]$ ]]; then
        echo ""
        log_warning "Push cancelled per Protocol 4"
        log ""
        log "Next steps:"
        log "  1. Invoke code-reviewer agent in Claude Code"
        log "  2. Address all issues found"
        log "  3. If remote keeps finding missed issues â†’ use adversarial-reviewer"
        log "  4. Retry push after clean local review"
        echo ""
        exit 1
      fi
    fi
  fi
}

# Run PR review checkpoint before config sync
check_pr_review_iteration

# =========================================================
# CONFIGURATION HARDLINKS (Pre-push)
# =========================================================

ensure_config_hardlinks() {
  local repo_root
  repo_root=$(git rev-parse --show-toplevel)

  # Define config mappings: global_path:repo_filename
  local configs=(
    "${HOME}/.config/shellcheck/.shellcheckrc:.shellcheckrc"
    "${HOME}/.config/yamllint/config:.yamllint"
  )

  local any_updated=false

  for config_mapping in "${configs[@]}"; do
    local global_config="${config_mapping%:*}"
    local repo_filename="${config_mapping#*:}"
    local repo_config="${repo_root}/.github/workflows/${repo_filename}"

    if [[ -f "${global_config}" ]]; then
      # Ensure .github/workflows directory exists
      mkdir -p "${repo_root}/.github/workflows"

      # Check if repo config is missing or different
      if [[ ! -f "${repo_config}" ]] || ! cmp -s "${global_config}" "${repo_config}"; then
        # Remove existing repo config (file or broken link)
        rm -f "${repo_config}"
        # Create hardlink to global config
        if ln "${global_config}" "${repo_config}" 2>/dev/null; then
          log_success "âœ… Updated ${repo_filename} in .github/workflows/ from global config"
          git add "${repo_config}" 2>/dev/null || true
          any_updated=true
        else
          log_warning "âš ï¸  Could not create hardlink for ${repo_filename} (cross-filesystem)"
          # Fallback to copy
          cp "${global_config}" "${repo_config}"
          log_success "ðŸ“‹ Copied ${repo_filename} to .github/workflows/ from global config"
          git add "${repo_config}" 2>/dev/null || true
          any_updated=true
        fi
      fi
    elif [[ ! -f "${repo_config}" ]]; then
      log_warning "âš ï¸  No ${repo_filename} config found (neither global nor repo)"
    fi
  done

  if [[ "${any_updated}" == true ]]; then
    # Check if there are actually staged changes (files might already be committed)
    if ! git diff --cached --quiet 2>/dev/null; then
      echo "" >&2
      log_success "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      log_success "ðŸ”„ CONFIG SYNC: Auto-committing updated workflow configs"
      log_success "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      log "Creating commit with synced config files from global settings..."
      echo "" >&2

      # Create auto-commit with synced configs (use --no-verify to avoid hook recursion)
      if git commit --no-verify -m "chore(ci): sync workflow configs from global settings" 2>&1; then
        log_success "âœ… Auto-commit created - config files will be included in push"
      else
        log_warning "âš ï¸  Could not create auto-commit (may already be committed)"
      fi
      echo "" >&2
    else
      log "âœ… Config files synced (no changes to commit)"
    fi
  else
    log "âœ… All config files in .github/workflows/ are up to date"
  fi
}

# Check if remote is GitHub
is_github_remote() {
  local remote_url
  remote_url=$(git remote get-url origin 2>/dev/null || echo "")

  if [[ "${remote_url}" =~ github\.com ]]; then
    return 0
  else
    return 1
  fi
}

# Check if GitHub workflows exist that use config files
has_github_workflows_using_configs() {
  local repo_root
  repo_root=$(git rev-parse --show-toplevel)

  # Check if .github/workflows directory exists
  if [[ ! -d "${repo_root}/.github/workflows" ]]; then
    return 1
  fi

  # Check if any workflow files reference the config files we manage
  if grep -r "\.shellcheckrc\|\.yamllint" "${repo_root}/.github/workflows/" >/dev/null 2>&1; then
    return 0
  else
    return 1
  fi
}

# Main execution
if is_github_remote && has_github_workflows_using_configs; then
  log "GitHub remote with CI workflows detected - syncing configuration files before push..."
  ensure_config_hardlinks
elif is_github_remote; then
  log "GitHub remote detected but no workflows use config files - skipping config sync"
else
  log "Non-GitHub remote detected - skipping config sync"
fi

log_success "Pre-push config sync complete!"
